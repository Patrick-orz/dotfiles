"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Scheduler = void 0;
var _Semaphore = require("../utils/Semaphore");
var __assign = void 0 && (void 0).__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = void 0 && (void 0).__generator || function (thisArg, body) {
  var _ = {
      label: 0,
      sent: function () {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
    f,
    y,
    t,
    g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;
  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};
var __values = void 0 && (void 0).__values || function (o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
    m = s && o[s],
    i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function () {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
/**
 * Module for scheduling and optimization of translate a text streams
 *
 * - It can union many translate requests to one
 * - You can group any requests by context
 * - It's configurable. You can set retry limit and edge for direct translate
 */
var Scheduler = /** @class */function () {
  function Scheduler(translator, config) {
    var _this = this;
    this.config = {
      translateRetryAttemptLimit: 2,
      isAllowDirectTranslateBadChunks: true,
      directTranslateLength: null,
      translatePoolDelay: 300,
      chunkSizeForInstantTranslate: null,
      taskBatchHandleDelay: null
    };
    this.contextCounter = 0;
    this.taskContainersStorage = new Set();
    this.timersMap = new Map();
    /**
     * Tasks queue with items sorted by priority
     * It must be handled from end to start
     */
    this.translateQueue = [];
    /**
     * Return first item from queue and delete it from queue
     * Items is sorted by priority
     */
    this.getItemFromTranslateQueue = function () {
      var _a;
      return {
        done: _this.translateQueue.length === 0,
        value: (_a = _this.translateQueue.pop()) !== null && _a !== void 0 ? _a : null
      };
    };
    this.workerState = false;
    this.translator = translator;
    if (config !== undefined) {
      for (var key in config) {
        this.config[key] = config[key];
      }
    }
    this.semafor = new _Semaphore.Semaphore({
      timeout: translator.getRequestsTimeout()
    });
  }
  Scheduler.prototype.translate = function (text, from, to, options) {
    return __awaiter(this, void 0, void 0, function () {
      var _a, _b, context, _c, priority, _d, directTranslateForThisRequest;
      return __generator(this, function (_e) {
        _a = options !== undefined ? options : {}, _b = _a.context, context = _b === void 0 ? '' : _b, _c = _a.priority, priority = _c === void 0 ? 0 : _c, _d = _a.directTranslate, directTranslateForThisRequest = _d === void 0 ? false : _d;
        if (this.translator.checkLimitExceeding(text) <= 0) {
          // Direct translate
          if (directTranslateForThisRequest || this.config.directTranslateLength !== null && text.length >= this.config.directTranslateLength) {
            return [2 /*return*/, this.directTranslate(text, from, to)];
          } else {
            return [2 /*return*/, this.makeTask({
              text: text,
              from: from,
              to: to,
              context: context,
              priority: priority
            })];
          }
        } else {
          // Split text by words and translate
          return [2 /*return*/, this.splitAndTranslate(text, from, to, context, priority)];
        }
        return [2 /*return*/];
      });
    });
  };

  Scheduler.prototype.directTranslate = function (text, from, to) {
    return __awaiter(this, void 0, void 0, function () {
      var free;
      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            return [4 /*yield*/, this.semafor.take()];
          case 1:
            free = _a.sent();
            return [2 /*return*/, this.translator.translate(text, from, to).finally(free)];
        }
      });
    });
  };
  Scheduler.prototype.splitAndTranslate = function (text, from, to, context, priority) {
    var e_1, _a;
    var _this = this;
    var splittedText = [];
    var charsetIndexes = [];
    var wordsBuffer = '';
    try {
      for (var _b = __values(text.matchAll(/([^\s]+)(\s*)/g)), _c = _b.next(); !_c.done; _c = _b.next()) {
        var textMatch = _c.value;
        var newPart = textMatch[0];
        var newBuffer = wordsBuffer + newPart;
        // Add word to buffer if can
        if (this.translator.checkLimitExceeding(newBuffer) <= 0) {
          wordsBuffer = newBuffer;
          continue;
        }
        // Write and clear buffer if not empthy
        if (wordsBuffer.length > 0) {
          splittedText.push(wordsBuffer);
          wordsBuffer = '';
        }
        // Handle new part
        if (this.translator.checkLimitExceeding(newPart) <= 0) {
          // Add to buffer
          wordsBuffer += newPart;
          continue;
        } else {
          // Slice by chars
          var charsBuffer = newPart;
          while (charsBuffer.length > 0) {
            var extraChars = this.translator.checkLimitExceeding(charsBuffer);
            if (extraChars > 0) {
              var offset = charsBuffer.length - extraChars;
              // Write slice and remainder
              splittedText.push(charsBuffer.slice(0, offset));
              charsBuffer = charsBuffer.slice(offset);
              charsetIndexes.push(splittedText.length - 1);
            }
          }
        }
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    var ctxPrefix = context.length > 0 ? context + ';' : '';
    return Promise.all(splittedText.map(function (text, index) {
      return charsetIndexes.indexOf(index) !== -1 ? text : _this.makeTask({
        text: text,
        from: from,
        to: to,
        context: ctxPrefix + "text#".concat(_this.contextCounter++),
        priority: priority
      });
    })).then(function (translatedParts) {
      return translatedParts.join('');
    });
  };
  Scheduler.prototype.makeTask = function (_a) {
    var _this = this;
    var text = _a.text,
      from = _a.from,
      to = _a.to,
      priority = _a.priority,
      _b = _a.context,
      context = _b === void 0 ? '' : _b;
    return new Promise(function (resolve, reject) {
      _this.addToTaskContainer({
        text: text,
        from: from,
        to: to,
        context: context,
        priority: priority,
        resolve: resolve,
        reject: reject
      });
    });
  };
  Scheduler.prototype.addToTaskContainer = function (params) {
    var e_2, _a;
    var text = params.text,
      from = params.from,
      to = params.to,
      _b = params.attempt,
      attempt = _b === void 0 ? 0 : _b,
      _c = params.context,
      context = _c === void 0 ? '' : _c,
      priority = params.priority,
      resolve = params.resolve,
      reject = params.reject;
    // create task
    var task = {
      text: text,
      from: from,
      to: to,
      attempt: attempt,
      resolve: resolve,
      reject: reject
    };
    var container = null;
    var _loop_1 = function (taskContainer) {
      // Skip containers with not equal parameters
      if (['from', 'to', 'context', 'priority'].some(function (key) {
        return params[key] !== taskContainer[key];
      })) return "continue";
      // Lightweight check to overflow
      // NOTE: Do strict check here if you need comply a limit contract
      if (this_1.translator.getLengthLimit() >= taskContainer.length + task.text.length) {
        taskContainer.tasks.push(task);
        taskContainer.length += task.text.length;
        container = taskContainer;
      }
    };
    var this_1 = this;
    try {
      // try add to exists container
      for (var _d = __values(this.taskContainersStorage), _e = _d.next(); !_e.done; _e = _d.next()) {
        var taskContainer = _e.value;
        _loop_1(taskContainer);
      }
    } catch (e_2_1) {
      e_2 = {
        error: e_2_1
      };
    } finally {
      try {
        if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
      } finally {
        if (e_2) throw e_2.error;
      }
    }
    // make container
    if (container === null) {
      var newTaskContainer = {
        context: context,
        priority: priority,
        from: from,
        to: to,
        tasks: [task],
        length: task.text.length
      };
      this.taskContainersStorage.add(newTaskContainer);
      container = newTaskContainer;
    }
    if (this.config.chunkSizeForInstantTranslate !== null && container.length >= this.config.chunkSizeForInstantTranslate) {
      this.addToTranslateQueue(container);
    } else {
      this.updateDelayForAddToTranslateQueue(container);
    }
  };
  Scheduler.prototype.updateDelayForAddToTranslateQueue = function (taskContainer) {
    var _this = this;
    // Flush timer
    if (this.timersMap.has(taskContainer)) {
      // Due to expectation run on one platform, timer objects will same always
      globalThis.clearTimeout(this.timersMap.get(taskContainer));
    }
    this.timersMap.set(taskContainer, globalThis.setTimeout(function () {
      _this.addToTranslateQueue(taskContainer);
    }, this.config.translatePoolDelay));
  };
  Scheduler.prototype.addToTranslateQueue = function (taskContainer) {
    // Flush timer
    if (this.timersMap.has(taskContainer)) {
      // Due to expectation run on one platform, timer objects will same always
      globalThis.clearTimeout(this.timersMap.get(taskContainer));
      this.timersMap.delete(taskContainer);
    }
    this.taskContainersStorage.delete(taskContainer);
    // Resort queue by priority each time to keep consistency
    this.translateQueue = this.translateQueue.concat(taskContainer).sort(function (a, b) {
      return a.priority - b.priority;
    });
    if (!this.workerState) {
      this.runWorker();
    }
  };
  Scheduler.prototype.runWorker = function () {
    return __awaiter(this, void 0, void 0, function () {
      var firstIteration, _loop_2, this_2, state_1;
      var _this = this;
      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            this.workerState = true;
            firstIteration = true;
            _loop_2 = function () {
              var workerHandleDelay, iterate, taskContainer, free, textArray;
              return __generator(this, function (_b) {
                switch (_b.label) {
                  case 0:
                    workerHandleDelay = this_2.config.taskBatchHandleDelay;
                    if (!(workerHandleDelay && firstIteration)) return [3 /*break*/, 2];
                    return [4 /*yield*/, new Promise(function (res) {
                      return setTimeout(res, workerHandleDelay);
                    })];
                  case 1:
                    _b.sent();
                    _b.label = 2;
                  case 2:
                    firstIteration = false;
                    iterate = this_2.getItemFromTranslateQueue();
                    // Skip when queue empty
                    if (iterate.done || iterate.value === null) return [2 /*return*/, "break"];
                    taskContainer = iterate.value;
                    return [4 /*yield*/, this_2.semafor.take()];
                  case 3:
                    free = _b.sent();
                    textArray = taskContainer.tasks.map(function (i) {
                      return i.text;
                    });
                    return [4 /*yield*/, this_2.translator.translateBatch(textArray, taskContainer.from, taskContainer.to).then(function (result) {
                      for (var index in taskContainer.tasks) {
                        var task = taskContainer.tasks[index];
                        var translatedText = result[index];
                        if (translatedText !== null) {
                          task.resolve(translatedText);
                        } else {
                          _this.taskErrorHandler(task, new Error("Translator module can't translate this"), taskContainer.context, taskContainer.priority);
                        }
                      }
                    }).catch(function (reason) {
                      var e_3, _a;
                      console.error(reason);
                      try {
                        for (var _b = (e_3 = void 0, __values(taskContainer.tasks)), _c = _b.next(); !_c.done; _c = _b.next()) {
                          var task = _c.value;
                          _this.taskErrorHandler(task, reason, taskContainer.context, taskContainer.priority);
                        }
                      } catch (e_3_1) {
                        e_3 = {
                          error: e_3_1
                        };
                      } finally {
                        try {
                          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        } finally {
                          if (e_3) throw e_3.error;
                        }
                      }
                    }).finally(free)];
                  case 4:
                    _b.sent();
                    return [2 /*return*/];
                }
              });
            };

            this_2 = this;
            _a.label = 1;
          case 1:
            if (!true) return [3 /*break*/, 3];
            return [5 /*yield**/, _loop_2()];
          case 2:
            state_1 = _a.sent();
            if (state_1 === "break") return [3 /*break*/, 3];
            return [3 /*break*/, 1];
          case 3:
            this.workerState = false;
            return [2 /*return*/];
        }
      });
    });
  };

  Scheduler.prototype.taskErrorHandler = function (task, error, context, priority) {
    if (task.attempt >= this.config.translateRetryAttemptLimit) {
      if (this.config.isAllowDirectTranslateBadChunks) {
        var text = task.text,
          from = task.from,
          to = task.to,
          resolve = task.resolve,
          reject = task.reject;
        this.directTranslate(text, from, to).then(resolve, reject);
      } else {
        task.reject(error);
      }
    } else {
      this.addToTaskContainer(__assign(__assign({}, task), {
        attempt: task.attempt + 1,
        context: context,
        priority: priority
      }));
    }
  };
  return Scheduler;
}();
exports.Scheduler = Scheduler;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2NoZWR1bGluZy9TY2hlZHVsZXIuanMiLCJuYW1lcyI6WyJfU2VtYXBob3JlIiwicmVxdWlyZSIsIlNjaGVkdWxlciIsInRyYW5zbGF0b3IiLCJjb25maWciLCJfdGhpcyIsInRyYW5zbGF0ZVJldHJ5QXR0ZW1wdExpbWl0IiwiaXNBbGxvd0RpcmVjdFRyYW5zbGF0ZUJhZENodW5rcyIsImRpcmVjdFRyYW5zbGF0ZUxlbmd0aCIsInRyYW5zbGF0ZVBvb2xEZWxheSIsImNodW5rU2l6ZUZvckluc3RhbnRUcmFuc2xhdGUiLCJ0YXNrQmF0Y2hIYW5kbGVEZWxheSIsImNvbnRleHRDb3VudGVyIiwidGFza0NvbnRhaW5lcnNTdG9yYWdlIiwiU2V0IiwidGltZXJzTWFwIiwiTWFwIiwidHJhbnNsYXRlUXVldWUiLCJnZXRJdGVtRnJvbVRyYW5zbGF0ZVF1ZXVlIiwiZG9uZSIsImxlbmd0aCIsInZhbHVlIiwiX2EiLCJwb3AiLCJ3b3JrZXJTdGF0ZSIsInVuZGVmaW5lZCIsImtleSIsInNlbWFmb3IiLCJTZW1hcGhvcmUiLCJ0aW1lb3V0IiwiZ2V0UmVxdWVzdHNUaW1lb3V0IiwicHJvdG90eXBlIiwidHJhbnNsYXRlIiwidGV4dCIsImZyb20iLCJ0byIsIm9wdGlvbnMiLCJfYiIsImNvbnRleHQiLCJfYyIsInByaW9yaXR5IiwiX2QiLCJkaXJlY3RUcmFuc2xhdGUiLCJkaXJlY3RUcmFuc2xhdGVGb3JUaGlzUmVxdWVzdCIsImNoZWNrTGltaXRFeGNlZWRpbmciLCJtYWtlVGFzayIsInNwbGl0QW5kVHJhbnNsYXRlIiwidGFrZSIsImZyZWUiLCJzZW50IiwiZmluYWxseSIsInNwbGl0dGVkVGV4dCIsImNoYXJzZXRJbmRleGVzIiwid29yZHNCdWZmZXIiLCJfX3ZhbHVlcyIsIm1hdGNoQWxsIiwibmV4dCIsInRleHRNYXRjaCIsIm5ld1BhcnQiLCJuZXdCdWZmZXIiLCJwdXNoIiwiY2hhcnNCdWZmZXIiLCJleHRyYUNoYXJzIiwib2Zmc2V0Iiwic2xpY2UiLCJjdHhQcmVmaXgiLCJQcm9taXNlIiwiYWxsIiwibWFwIiwiaW5kZXgiLCJpbmRleE9mIiwiY29uY2F0IiwidGhlbiIsInRyYW5zbGF0ZWRQYXJ0cyIsImpvaW4iLCJyZXNvbHZlIiwicmVqZWN0IiwiYWRkVG9UYXNrQ29udGFpbmVyIiwicGFyYW1zIiwiYXR0ZW1wdCIsInRhc2siLCJjb250YWluZXIiLCJ0YXNrQ29udGFpbmVyIiwic29tZSIsInRoaXNfMSIsImdldExlbmd0aExpbWl0IiwidGFza3MiLCJfZSIsIm5ld1Rhc2tDb250YWluZXIiLCJhZGQiLCJhZGRUb1RyYW5zbGF0ZVF1ZXVlIiwidXBkYXRlRGVsYXlGb3JBZGRUb1RyYW5zbGF0ZVF1ZXVlIiwiaGFzIiwiZ2xvYmFsVGhpcyIsImNsZWFyVGltZW91dCIsImdldCIsInNldCIsInNldFRpbWVvdXQiLCJkZWxldGUiLCJzb3J0IiwiYSIsImIiLCJydW5Xb3JrZXIiLCJmaXJzdEl0ZXJhdGlvbiIsIndvcmtlckhhbmRsZURlbGF5IiwidGhpc18yIiwicmVzIiwiaXRlcmF0ZSIsInRleHRBcnJheSIsImkiLCJ0cmFuc2xhdGVCYXRjaCIsInJlc3VsdCIsInRyYW5zbGF0ZWRUZXh0IiwidGFza0Vycm9ySGFuZGxlciIsIkVycm9yIiwiY2F0Y2giLCJyZWFzb24iLCJjb25zb2xlIiwiZXJyb3IiLCJlXzMiLCJfX2Fzc2lnbiIsImV4cG9ydHMiXSwic291cmNlcyI6WyJzY2hlZHVsaW5nL1NjaGVkdWxlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJU2NoZWR1bGVyVHJhbnNsYXRlT3B0aW9ucywgSVNjaGVkdWxlciB9IGZyb20gJy4nO1xuaW1wb3J0IHtcblx0bGFuZ0NvZGUsXG5cdGxhbmdDb2RlV2l0aEF1dG8sXG5cdFRyYW5zbGF0b3JJbnN0YW5jZU1lbWJlcnMsXG59IGZyb20gJy4uL3RyYW5zbGF0b3JzL1RyYW5zbGF0b3InO1xuaW1wb3J0IHsgU2VtYXBob3JlIH0gZnJvbSAnLi4vdXRpbHMvU2VtYXBob3JlJztcblxuaW50ZXJmYWNlIFNjaGVkdWxlckNvbmZpZyB7XG5cdC8qKlxuXHQgKiBOdW1iZXIgb2YgYXR0ZW1wdHMgZm9yIHJldHJ5IHJlcXVlc3Rcblx0ICovXG5cdHRyYW5zbGF0ZVJldHJ5QXR0ZW1wdExpbWl0PzogbnVtYmVyO1xuXG5cdC8qKlxuXHQgKiBJZiB0cnVlIC0gcmVqZWN0ZWQgcmVxdWVzdHMgd2lsbCB1c2UgZGlyZWN0IHRyYW5zbGF0ZVxuXHQgKi9cblx0aXNBbGxvd0RpcmVjdFRyYW5zbGF0ZUJhZENodW5rcz86IGJvb2xlYW47XG5cblx0LyoqXG5cdCAqIExlbmd0aCBvZiBzdHJpbmcgZm9yIGRpcmVjdCB0cmFuc2xhdGUuXG5cdCAqXG5cdCAqIG51bGwgZm9yIGRpc2FibGUgdGhlIGNvbmRpdGlvblxuXHQgKi9cblx0ZGlyZWN0VHJhbnNsYXRlTGVuZ3RoPzogbnVtYmVyIHwgbnVsbDtcblxuXHQvKipcblx0ICogRGVsYXkgZm9yIHRyYW5zbGF0ZSBhIGNodW5rLiBUaGUgYmlnZ2VyIHRoZSBtb3JlIHJlcXVlc3RzIHdpbGwgY29sbGVjdFxuXHQgKi9cblx0dHJhbnNsYXRlUG9vbERlbGF5PzogbnVtYmVyO1xuXG5cdC8qKlxuXHQgKiBXaGVuIGNodW5rIGNvbGxlY3QgdGhpcyBzaXplLCBpdCdzIHdpbGwgYmUgaW5zdGFudCBhZGQgdG8gYSB0cmFuc2xhdGUgcXVldWVcblx0ICpcblx0ICogbnVsbCBmb3IgZGlzYWJsZSB0aGUgY29uZGl0aW9uXG5cdCAqL1xuXHRjaHVua1NpemVGb3JJbnN0YW50VHJhbnNsYXRlPzogbnVtYmVyIHwgbnVsbDtcblxuXHQvKipcblx0ICogUGF1c2UgYmV0d2VlbiBoYW5kbGUgdGFzayBiYXRjaGVzXG5cdCAqXG5cdCAqIEl0IG1heSBiZSB1c2VmdWwgdG8gYXdhaXQgYWNjdW11bGF0aW5nIGEgdGFzayBiYXRjaGVzIGluIHF1ZXVlIHRvIGNvbnNpZGVyIHByaW9yaXR5IGJldHRlciBhbmQgZG9uJ3QgdHJhbnNsYXRlIGZpcnN0IHRhc2sgYmF0Y2ggaW1tZWRpYXRlbHlcblx0ICpcblx0ICogV0FSTklORzogdGhpcyBvcHRpb24gbXVzdCBiZSB1c2VkIG9ubHkgZm9yIGNvbnNpZGVyIHByaW9yaXR5IGJldHRlciEgU2V0IHNtYWxsIHZhbHVlIGFsd2F5cyAoMTAtNTBtcylcblx0ICpcblx0ICogV2hlbiB0aGlzIG9wdGlvbiBpcyBkaXNhYmxlZCAoYnkgZGVmYXVsdCkgYW5kIHlvdSBjYWxsIHRyYW5zbGF0ZSBtZXRob2QgZm9yIHRleHRzIHdpdGggcHJpb3JpdHkgMSBhbmQgdGhlbiBpbW1lZGlhdGVseSBmb3IgdGV4dCB3aXRoIHByaW9yaXR5IDIsIGZpcnN0IHJlcXVlc3Qgd2lsbCBoYXZlIGxlc3MgZGVsYXkgZm9yIHRyYW5zbGF0ZSBhbmQgd2lsbCB0cmFuc2xhdGUgZmlyc3QsIGV2ZW4gd2l0aCBsb3dlciBwcmlvcml0eSwgYmVjYXVzZSB3b3JrZXIgd2lsbCB0cmFuc2xhdGUgZmlyc3QgdGFzayBpbW1lZGlhdGVseSBhZnRlciBkZWxheSBkZWZpbmVkIGJ5IG9wdGlvbiBgdHJhbnNsYXRlUG9vbERlbGF5YFxuXHQgKi9cblx0dGFza0JhdGNoSGFuZGxlRGVsYXk/OiBudWxsIHwgbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgVGFza0NvbnN0cnVjdG9yIHtcblx0dGV4dDogc3RyaW5nO1xuXHRmcm9tOiBsYW5nQ29kZVdpdGhBdXRvO1xuXHR0bzogbGFuZ0NvZGU7XG5cblx0LyoqXG5cdCAqIFRvIGNvbWJpbmUgdGFza3MgYnkgdW5pcXVlIGtleVxuXHQgKi9cblx0Y29udGV4dD86IHN0cmluZztcblxuXHQvKipcblx0ICogVG8gY29tYmluZSBhbmQgc29ydCB0YXNrcyBieSBwcmlvcml0eVxuXHQgKi9cblx0cHJpb3JpdHk6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIFRhc2tDb25zdHJ1Y3RvckludGVybmFsIGV4dGVuZHMgVGFza0NvbnN0cnVjdG9yIHtcblx0LyoqXG5cdCAqIEN1cnJlbnQgcmV0cnkgYXR0ZW1wdFxuXHQgKi9cblx0YXR0ZW1wdD86IG51bWJlcjtcblxuXHRyZXNvbHZlOiAodmFsdWU6IHN0cmluZyB8IFByb21pc2VMaWtlPHN0cmluZz4pID0+IHZvaWQ7XG5cdHJlamVjdDogKHJlYXNvbj86IGFueSkgPT4gdm9pZDtcbn1cblxuaW50ZXJmYWNlIFRhc2sge1xuXHR0ZXh0OiBzdHJpbmc7XG5cdGZyb206IGxhbmdDb2RlV2l0aEF1dG87XG5cdHRvOiBsYW5nQ29kZTtcblxuXHQvKipcblx0ICogQ3VycmVudCByZXRyeSBhdHRlbXB0XG5cdCAqL1xuXHRhdHRlbXB0OiBudW1iZXI7XG5cblx0cmVzb2x2ZTogKHZhbHVlOiBzdHJpbmcgfCBQcm9taXNlTGlrZTxzdHJpbmc+KSA9PiB2b2lkO1xuXHRyZWplY3Q6IChyZWFzb24/OiBhbnkpID0+IHZvaWQ7XG59XG5cbmludGVyZmFjZSBUYXNrQ29udGFpbmVyIHtcblx0LyoqXG5cdCAqIEZvciBjb21iaW5lIHRhc2tzIGJ5IHVuaXF1ZSBrZXlcblx0ICovXG5cdGNvbnRleHQ6IHN0cmluZztcblxuXHRwcmlvcml0eTogbnVtYmVyO1xuXG5cdGZyb206IGxhbmdDb2RlV2l0aEF1dG87XG5cdHRvOiBsYW5nQ29kZTtcblx0dGFza3M6IFRhc2tbXTtcblxuXHQvKipcblx0ICogVG90YWwgbGVuZ3RoIG9mIHRleHQgZnJvbSBhbGwgdGFza3Ncblx0ICovXG5cdGxlbmd0aDogbnVtYmVyO1xufVxuXG50eXBlIEl0ZXJhdG9yU3RlcDxUPiA9IHtcblx0ZG9uZTogYm9vbGVhbjtcblx0dmFsdWU6IFQgfCBudWxsO1xufTtcblxuLyoqXG4gKiBNb2R1bGUgZm9yIHNjaGVkdWxpbmcgYW5kIG9wdGltaXphdGlvbiBvZiB0cmFuc2xhdGUgYSB0ZXh0IHN0cmVhbXNcbiAqXG4gKiAtIEl0IGNhbiB1bmlvbiBtYW55IHRyYW5zbGF0ZSByZXF1ZXN0cyB0byBvbmVcbiAqIC0gWW91IGNhbiBncm91cCBhbnkgcmVxdWVzdHMgYnkgY29udGV4dFxuICogLSBJdCdzIGNvbmZpZ3VyYWJsZS4gWW91IGNhbiBzZXQgcmV0cnkgbGltaXQgYW5kIGVkZ2UgZm9yIGRpcmVjdCB0cmFuc2xhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIFNjaGVkdWxlciBpbXBsZW1lbnRzIElTY2hlZHVsZXIge1xuXHRwcml2YXRlIHJlYWRvbmx5IHNlbWFmb3I7XG5cdHByaXZhdGUgcmVhZG9ubHkgdHJhbnNsYXRvcjtcblx0cHJpdmF0ZSByZWFkb25seSBjb25maWc6IFJlcXVpcmVkPFNjaGVkdWxlckNvbmZpZz4gPSB7XG5cdFx0dHJhbnNsYXRlUmV0cnlBdHRlbXB0TGltaXQ6IDIsXG5cdFx0aXNBbGxvd0RpcmVjdFRyYW5zbGF0ZUJhZENodW5rczogdHJ1ZSxcblx0XHRkaXJlY3RUcmFuc2xhdGVMZW5ndGg6IG51bGwsXG5cdFx0dHJhbnNsYXRlUG9vbERlbGF5OiAzMDAsXG5cdFx0Y2h1bmtTaXplRm9ySW5zdGFudFRyYW5zbGF0ZTogbnVsbCxcblx0XHR0YXNrQmF0Y2hIYW5kbGVEZWxheTogbnVsbCxcblx0fTtcblxuXHRjb25zdHJ1Y3Rvcih0cmFuc2xhdG9yOiBUcmFuc2xhdG9ySW5zdGFuY2VNZW1iZXJzLCBjb25maWc/OiBTY2hlZHVsZXJDb25maWcpIHtcblx0XHR0aGlzLnRyYW5zbGF0b3IgPSB0cmFuc2xhdG9yO1xuXG5cdFx0aWYgKGNvbmZpZyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRmb3IgKGNvbnN0IGtleSBpbiBjb25maWcpIHtcblx0XHRcdFx0KHRoaXMuY29uZmlnIGFzIGFueSlba2V5XSA9IChjb25maWcgYXMgYW55KVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuc2VtYWZvciA9IG5ldyBTZW1hcGhvcmUoeyB0aW1lb3V0OiB0cmFuc2xhdG9yLmdldFJlcXVlc3RzVGltZW91dCgpIH0pO1xuXHR9XG5cblx0cHJpdmF0ZSBjb250ZXh0Q291bnRlciA9IDA7XG5cdHB1YmxpYyBhc3luYyB0cmFuc2xhdGUoXG5cdFx0dGV4dDogc3RyaW5nLFxuXHRcdGZyb206IGxhbmdDb2RlV2l0aEF1dG8sXG5cdFx0dG86IGxhbmdDb2RlLFxuXHRcdG9wdGlvbnM/OiBJU2NoZWR1bGVyVHJhbnNsYXRlT3B0aW9ucyxcblx0KSB7XG5cdFx0Y29uc3Qge1xuXHRcdFx0Y29udGV4dCA9ICcnLFxuXHRcdFx0cHJpb3JpdHkgPSAwLFxuXHRcdFx0ZGlyZWN0VHJhbnNsYXRlOiBkaXJlY3RUcmFuc2xhdGVGb3JUaGlzUmVxdWVzdCA9IGZhbHNlLFxuXHRcdH0gPSBvcHRpb25zICE9PSB1bmRlZmluZWQgPyBvcHRpb25zIDoge307XG5cblx0XHRpZiAodGhpcy50cmFuc2xhdG9yLmNoZWNrTGltaXRFeGNlZWRpbmcodGV4dCkgPD0gMCkge1xuXHRcdFx0Ly8gRGlyZWN0IHRyYW5zbGF0ZVxuXHRcdFx0aWYgKFxuXHRcdFx0XHRkaXJlY3RUcmFuc2xhdGVGb3JUaGlzUmVxdWVzdCB8fFxuXHRcdFx0XHQodGhpcy5jb25maWcuZGlyZWN0VHJhbnNsYXRlTGVuZ3RoICE9PSBudWxsICYmXG5cdFx0XHRcdFx0dGV4dC5sZW5ndGggPj0gdGhpcy5jb25maWcuZGlyZWN0VHJhbnNsYXRlTGVuZ3RoKVxuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmRpcmVjdFRyYW5zbGF0ZSh0ZXh0LCBmcm9tLCB0byk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5tYWtlVGFzayh7IHRleHQ6IHRleHQsIGZyb20sIHRvLCBjb250ZXh0LCBwcmlvcml0eSB9KTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gU3BsaXQgdGV4dCBieSB3b3JkcyBhbmQgdHJhbnNsYXRlXG5cdFx0XHRyZXR1cm4gdGhpcy5zcGxpdEFuZFRyYW5zbGF0ZSh0ZXh0LCBmcm9tLCB0bywgY29udGV4dCwgcHJpb3JpdHkpO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgZGlyZWN0VHJhbnNsYXRlKHRleHQ6IHN0cmluZywgZnJvbTogbGFuZ0NvZGVXaXRoQXV0bywgdG86IGxhbmdDb2RlKSB7XG5cdFx0Y29uc3QgZnJlZSA9IGF3YWl0IHRoaXMuc2VtYWZvci50YWtlKCk7XG5cdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRvci50cmFuc2xhdGUodGV4dCwgZnJvbSwgdG8pLmZpbmFsbHkoZnJlZSk7XG5cdH1cblxuXHRwcml2YXRlIHNwbGl0QW5kVHJhbnNsYXRlKFxuXHRcdHRleHQ6IHN0cmluZyxcblx0XHRmcm9tOiBsYW5nQ29kZVdpdGhBdXRvLFxuXHRcdHRvOiBsYW5nQ29kZSxcblx0XHRjb250ZXh0OiBzdHJpbmcsXG5cdFx0cHJpb3JpdHk6IG51bWJlcixcblx0KSB7XG5cdFx0Y29uc3Qgc3BsaXR0ZWRUZXh0OiBzdHJpbmdbXSA9IFtdO1xuXHRcdGNvbnN0IGNoYXJzZXRJbmRleGVzOiBudW1iZXJbXSA9IFtdO1xuXG5cdFx0bGV0IHdvcmRzQnVmZmVyID0gJyc7XG5cdFx0Zm9yIChjb25zdCB0ZXh0TWF0Y2ggb2YgdGV4dC5tYXRjaEFsbCgvKFteXFxzXSspKFxccyopL2cpKSB7XG5cdFx0XHRjb25zdCBuZXdQYXJ0ID0gdGV4dE1hdGNoWzBdO1xuXHRcdFx0Y29uc3QgbmV3QnVmZmVyID0gd29yZHNCdWZmZXIgKyBuZXdQYXJ0O1xuXG5cdFx0XHQvLyBBZGQgd29yZCB0byBidWZmZXIgaWYgY2FuXG5cdFx0XHRpZiAodGhpcy50cmFuc2xhdG9yLmNoZWNrTGltaXRFeGNlZWRpbmcobmV3QnVmZmVyKSA8PSAwKSB7XG5cdFx0XHRcdHdvcmRzQnVmZmVyID0gbmV3QnVmZmVyO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV3JpdGUgYW5kIGNsZWFyIGJ1ZmZlciBpZiBub3QgZW1wdGh5XG5cdFx0XHRpZiAod29yZHNCdWZmZXIubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRzcGxpdHRlZFRleHQucHVzaCh3b3Jkc0J1ZmZlcik7XG5cdFx0XHRcdHdvcmRzQnVmZmVyID0gJyc7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhhbmRsZSBuZXcgcGFydFxuXHRcdFx0aWYgKHRoaXMudHJhbnNsYXRvci5jaGVja0xpbWl0RXhjZWVkaW5nKG5ld1BhcnQpIDw9IDApIHtcblx0XHRcdFx0Ly8gQWRkIHRvIGJ1ZmZlclxuXHRcdFx0XHR3b3Jkc0J1ZmZlciArPSBuZXdQYXJ0O1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFNsaWNlIGJ5IGNoYXJzXG5cdFx0XHRcdGxldCBjaGFyc0J1ZmZlciA9IG5ld1BhcnQ7XG5cdFx0XHRcdHdoaWxlIChjaGFyc0J1ZmZlci5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0Y29uc3QgZXh0cmFDaGFycyA9IHRoaXMudHJhbnNsYXRvci5jaGVja0xpbWl0RXhjZWVkaW5nKGNoYXJzQnVmZmVyKTtcblx0XHRcdFx0XHRpZiAoZXh0cmFDaGFycyA+IDApIHtcblx0XHRcdFx0XHRcdGNvbnN0IG9mZnNldCA9IGNoYXJzQnVmZmVyLmxlbmd0aCAtIGV4dHJhQ2hhcnM7XG5cblx0XHRcdFx0XHRcdC8vIFdyaXRlIHNsaWNlIGFuZCByZW1haW5kZXJcblx0XHRcdFx0XHRcdHNwbGl0dGVkVGV4dC5wdXNoKGNoYXJzQnVmZmVyLnNsaWNlKDAsIG9mZnNldCkpO1xuXHRcdFx0XHRcdFx0Y2hhcnNCdWZmZXIgPSBjaGFyc0J1ZmZlci5zbGljZShvZmZzZXQpO1xuXG5cdFx0XHRcdFx0XHRjaGFyc2V0SW5kZXhlcy5wdXNoKHNwbGl0dGVkVGV4dC5sZW5ndGggLSAxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRjb25zdCBjdHhQcmVmaXggPSBjb250ZXh0Lmxlbmd0aCA+IDAgPyBjb250ZXh0ICsgJzsnIDogJyc7XG5cdFx0cmV0dXJuIFByb21pc2UuYWxsKFxuXHRcdFx0c3BsaXR0ZWRUZXh0Lm1hcCgodGV4dCwgaW5kZXgpID0+XG5cdFx0XHRcdGNoYXJzZXRJbmRleGVzLmluZGV4T2YoaW5kZXgpICE9PSAtMVxuXHRcdFx0XHRcdD8gdGV4dFxuXHRcdFx0XHRcdDogdGhpcy5tYWtlVGFzayh7XG5cdFx0XHRcdFx0XHR0ZXh0LFxuXHRcdFx0XHRcdFx0ZnJvbSxcblx0XHRcdFx0XHRcdHRvLFxuXHRcdFx0XHRcdFx0Y29udGV4dDogY3R4UHJlZml4ICsgYHRleHQjJHt0aGlzLmNvbnRleHRDb3VudGVyKyt9YCxcblx0XHRcdFx0XHRcdHByaW9yaXR5LFxuXHRcdFx0XHRcdCAgfSksXG5cdFx0XHQpLFxuXHRcdCkudGhlbigodHJhbnNsYXRlZFBhcnRzKSA9PiB0cmFuc2xhdGVkUGFydHMuam9pbignJykpO1xuXHR9XG5cblx0cHJpdmF0ZSBtYWtlVGFzayh7IHRleHQsIGZyb20sIHRvLCBwcmlvcml0eSwgY29udGV4dCA9ICcnIH06IFRhc2tDb25zdHJ1Y3Rvcikge1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZTxzdHJpbmc+KChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRcdHRoaXMuYWRkVG9UYXNrQ29udGFpbmVyKHtcblx0XHRcdFx0dGV4dCxcblx0XHRcdFx0ZnJvbSxcblx0XHRcdFx0dG8sXG5cdFx0XHRcdGNvbnRleHQsXG5cdFx0XHRcdHByaW9yaXR5LFxuXHRcdFx0XHRyZXNvbHZlLFxuXHRcdFx0XHRyZWplY3QsXG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fVxuXG5cdHByaXZhdGUgcmVhZG9ubHkgdGFza0NvbnRhaW5lcnNTdG9yYWdlID0gbmV3IFNldDxUYXNrQ29udGFpbmVyPigpO1xuXHRwcml2YXRlIGFkZFRvVGFza0NvbnRhaW5lcihwYXJhbXM6IFRhc2tDb25zdHJ1Y3RvckludGVybmFsKSB7XG5cdFx0Y29uc3Qge1xuXHRcdFx0dGV4dCxcblx0XHRcdGZyb20sXG5cdFx0XHR0byxcblx0XHRcdGF0dGVtcHQgPSAwLFxuXHRcdFx0Y29udGV4dCA9ICcnLFxuXHRcdFx0cHJpb3JpdHksXG5cdFx0XHRyZXNvbHZlLFxuXHRcdFx0cmVqZWN0LFxuXHRcdH0gPSBwYXJhbXM7XG5cblx0XHQvLyBjcmVhdGUgdGFza1xuXHRcdGNvbnN0IHRhc2s6IFRhc2sgPSB7XG5cdFx0XHR0ZXh0LFxuXHRcdFx0ZnJvbSxcblx0XHRcdHRvLFxuXHRcdFx0YXR0ZW1wdCxcblx0XHRcdHJlc29sdmUsXG5cdFx0XHRyZWplY3QsXG5cdFx0fTtcblxuXHRcdGxldCBjb250YWluZXI6IFRhc2tDb250YWluZXIgfCBudWxsID0gbnVsbDtcblxuXHRcdC8vIHRyeSBhZGQgdG8gZXhpc3RzIGNvbnRhaW5lclxuXHRcdGZvciAoY29uc3QgdGFza0NvbnRhaW5lciBvZiB0aGlzLnRhc2tDb250YWluZXJzU3RvcmFnZSkge1xuXHRcdFx0Ly8gU2tpcCBjb250YWluZXJzIHdpdGggbm90IGVxdWFsIHBhcmFtZXRlcnNcblx0XHRcdGlmIChcblx0XHRcdFx0Wydmcm9tJywgJ3RvJywgJ2NvbnRleHQnLCAncHJpb3JpdHknXS5zb21lKFxuXHRcdFx0XHRcdChrZXkpID0+IChwYXJhbXMgYXMgYW55KVtrZXldICE9PSAodGFza0NvbnRhaW5lciBhcyBhbnkpW2tleV0sXG5cdFx0XHRcdClcblx0XHRcdClcblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdC8vIExpZ2h0d2VpZ2h0IGNoZWNrIHRvIG92ZXJmbG93XG5cdFx0XHQvLyBOT1RFOiBEbyBzdHJpY3QgY2hlY2sgaGVyZSBpZiB5b3UgbmVlZCBjb21wbHkgYSBsaW1pdCBjb250cmFjdFxuXHRcdFx0aWYgKFxuXHRcdFx0XHR0aGlzLnRyYW5zbGF0b3IuZ2V0TGVuZ3RoTGltaXQoKSA+PVxuXHRcdFx0XHR0YXNrQ29udGFpbmVyLmxlbmd0aCArIHRhc2sudGV4dC5sZW5ndGhcblx0XHRcdCkge1xuXHRcdFx0XHR0YXNrQ29udGFpbmVyLnRhc2tzLnB1c2godGFzayk7XG5cdFx0XHRcdHRhc2tDb250YWluZXIubGVuZ3RoICs9IHRhc2sudGV4dC5sZW5ndGg7XG5cdFx0XHRcdGNvbnRhaW5lciA9IHRhc2tDb250YWluZXI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gbWFrZSBjb250YWluZXJcblx0XHRpZiAoY29udGFpbmVyID09PSBudWxsKSB7XG5cdFx0XHRjb25zdCBuZXdUYXNrQ29udGFpbmVyOiBUYXNrQ29udGFpbmVyID0ge1xuXHRcdFx0XHRjb250ZXh0LFxuXHRcdFx0XHRwcmlvcml0eSxcblx0XHRcdFx0ZnJvbSxcblx0XHRcdFx0dG8sXG5cdFx0XHRcdHRhc2tzOiBbdGFza10sXG5cdFx0XHRcdGxlbmd0aDogdGFzay50ZXh0Lmxlbmd0aCxcblx0XHRcdH07XG5cdFx0XHR0aGlzLnRhc2tDb250YWluZXJzU3RvcmFnZS5hZGQobmV3VGFza0NvbnRhaW5lcik7XG5cdFx0XHRjb250YWluZXIgPSBuZXdUYXNrQ29udGFpbmVyO1xuXHRcdH1cblxuXHRcdGlmIChcblx0XHRcdHRoaXMuY29uZmlnLmNodW5rU2l6ZUZvckluc3RhbnRUcmFuc2xhdGUgIT09IG51bGwgJiZcblx0XHRcdGNvbnRhaW5lci5sZW5ndGggPj0gdGhpcy5jb25maWcuY2h1bmtTaXplRm9ySW5zdGFudFRyYW5zbGF0ZVxuXHRcdCkge1xuXHRcdFx0dGhpcy5hZGRUb1RyYW5zbGF0ZVF1ZXVlKGNvbnRhaW5lcik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMudXBkYXRlRGVsYXlGb3JBZGRUb1RyYW5zbGF0ZVF1ZXVlKGNvbnRhaW5lcik7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSByZWFkb25seSB0aW1lcnNNYXAgPSBuZXcgTWFwPFRhc2tDb250YWluZXIsIG51bWJlciB8IE5vZGVKUy5UaW1lb3V0PigpO1xuXHRwcml2YXRlIHVwZGF0ZURlbGF5Rm9yQWRkVG9UcmFuc2xhdGVRdWV1ZSh0YXNrQ29udGFpbmVyOiBUYXNrQ29udGFpbmVyKSB7XG5cdFx0Ly8gRmx1c2ggdGltZXJcblx0XHRpZiAodGhpcy50aW1lcnNNYXAuaGFzKHRhc2tDb250YWluZXIpKSB7XG5cdFx0XHQvLyBEdWUgdG8gZXhwZWN0YXRpb24gcnVuIG9uIG9uZSBwbGF0Zm9ybSwgdGltZXIgb2JqZWN0cyB3aWxsIHNhbWUgYWx3YXlzXG5cdFx0XHRnbG9iYWxUaGlzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVyc01hcC5nZXQodGFza0NvbnRhaW5lcikgYXMgYW55KTtcblx0XHR9XG5cblx0XHR0aGlzLnRpbWVyc01hcC5zZXQoXG5cdFx0XHR0YXNrQ29udGFpbmVyLFxuXHRcdFx0Z2xvYmFsVGhpcy5zZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0dGhpcy5hZGRUb1RyYW5zbGF0ZVF1ZXVlKHRhc2tDb250YWluZXIpO1xuXHRcdFx0fSwgdGhpcy5jb25maWcudHJhbnNsYXRlUG9vbERlbGF5KSxcblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRhc2tzIHF1ZXVlIHdpdGggaXRlbXMgc29ydGVkIGJ5IHByaW9yaXR5XG5cdCAqIEl0IG11c3QgYmUgaGFuZGxlZCBmcm9tIGVuZCB0byBzdGFydFxuXHQgKi9cblx0cHJpdmF0ZSB0cmFuc2xhdGVRdWV1ZTogVGFza0NvbnRhaW5lcltdID0gW107XG5cdHByaXZhdGUgYWRkVG9UcmFuc2xhdGVRdWV1ZSh0YXNrQ29udGFpbmVyOiBUYXNrQ29udGFpbmVyKSB7XG5cdFx0Ly8gRmx1c2ggdGltZXJcblx0XHRpZiAodGhpcy50aW1lcnNNYXAuaGFzKHRhc2tDb250YWluZXIpKSB7XG5cdFx0XHQvLyBEdWUgdG8gZXhwZWN0YXRpb24gcnVuIG9uIG9uZSBwbGF0Zm9ybSwgdGltZXIgb2JqZWN0cyB3aWxsIHNhbWUgYWx3YXlzXG5cdFx0XHRnbG9iYWxUaGlzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVyc01hcC5nZXQodGFza0NvbnRhaW5lcikgYXMgYW55KTtcblx0XHRcdHRoaXMudGltZXJzTWFwLmRlbGV0ZSh0YXNrQ29udGFpbmVyKTtcblx0XHR9XG5cblx0XHR0aGlzLnRhc2tDb250YWluZXJzU3RvcmFnZS5kZWxldGUodGFza0NvbnRhaW5lcik7XG5cblx0XHQvLyBSZXNvcnQgcXVldWUgYnkgcHJpb3JpdHkgZWFjaCB0aW1lIHRvIGtlZXAgY29uc2lzdGVuY3lcblx0XHR0aGlzLnRyYW5zbGF0ZVF1ZXVlID0gdGhpcy50cmFuc2xhdGVRdWV1ZVxuXHRcdFx0LmNvbmNhdCh0YXNrQ29udGFpbmVyKVxuXHRcdFx0LnNvcnQoKGEsIGIpID0+IGEucHJpb3JpdHkgLSBiLnByaW9yaXR5KTtcblxuXHRcdGlmICghdGhpcy53b3JrZXJTdGF0ZSkge1xuXHRcdFx0dGhpcy5ydW5Xb3JrZXIoKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJuIGZpcnN0IGl0ZW0gZnJvbSBxdWV1ZSBhbmQgZGVsZXRlIGl0IGZyb20gcXVldWVcblx0ICogSXRlbXMgaXMgc29ydGVkIGJ5IHByaW9yaXR5XG5cdCAqL1xuXHRwcml2YXRlIGdldEl0ZW1Gcm9tVHJhbnNsYXRlUXVldWUgPSAoKTogSXRlcmF0b3JTdGVwPFRhc2tDb250YWluZXI+ID0+IHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZG9uZTogdGhpcy50cmFuc2xhdGVRdWV1ZS5sZW5ndGggPT09IDAsXG5cdFx0XHR2YWx1ZTogdGhpcy50cmFuc2xhdGVRdWV1ZS5wb3AoKSA/PyBudWxsLFxuXHRcdH07XG5cdH07XG5cblx0cHJpdmF0ZSB3b3JrZXJTdGF0ZSA9IGZhbHNlO1xuXHRwcml2YXRlIGFzeW5jIHJ1bldvcmtlcigpIHtcblx0XHR0aGlzLndvcmtlclN0YXRlID0gdHJ1ZTtcblxuXHRcdGxldCBmaXJzdEl0ZXJhdGlvbiA9IHRydWU7XG5cdFx0d2hpbGUgKHRydWUpIHtcblx0XHRcdC8vIERlbGF5IGZpcnN0IGl0ZXJhdGlvbiB0byBhd2FpdCBmaWxsIHRoZSBxdWV1ZSwgdG8gY29uc2lkZXIgcHJpb3JpdHkgYmV0dGVyXG5cdFx0XHRjb25zdCB3b3JrZXJIYW5kbGVEZWxheSA9IHRoaXMuY29uZmlnLnRhc2tCYXRjaEhhbmRsZURlbGF5O1xuXHRcdFx0aWYgKHdvcmtlckhhbmRsZURlbGF5ICYmIGZpcnN0SXRlcmF0aW9uKSB7XG5cdFx0XHRcdGF3YWl0IG5ldyBQcm9taXNlKChyZXMpID0+IHNldFRpbWVvdXQocmVzLCB3b3JrZXJIYW5kbGVEZWxheSkpO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJzdEl0ZXJhdGlvbiA9IGZhbHNlO1xuXG5cdFx0XHRjb25zdCBpdGVyYXRlID0gdGhpcy5nZXRJdGVtRnJvbVRyYW5zbGF0ZVF1ZXVlKCk7XG5cblx0XHRcdC8vIFNraXAgd2hlbiBxdWV1ZSBlbXB0eVxuXHRcdFx0aWYgKGl0ZXJhdGUuZG9uZSB8fCBpdGVyYXRlLnZhbHVlID09PSBudWxsKSBicmVhaztcblxuXHRcdFx0Y29uc3QgdGFza0NvbnRhaW5lciA9IGl0ZXJhdGUudmFsdWU7XG5cblx0XHRcdGNvbnN0IGZyZWUgPSBhd2FpdCB0aGlzLnNlbWFmb3IudGFrZSgpO1xuXG5cdFx0XHRjb25zdCB0ZXh0QXJyYXkgPSB0YXNrQ29udGFpbmVyLnRhc2tzLm1hcCgoaSkgPT4gaS50ZXh0KTtcblx0XHRcdGF3YWl0IHRoaXMudHJhbnNsYXRvclxuXHRcdFx0XHQudHJhbnNsYXRlQmF0Y2godGV4dEFycmF5LCB0YXNrQ29udGFpbmVyLmZyb20sIHRhc2tDb250YWluZXIudG8pXG5cdFx0XHRcdC50aGVuKChyZXN1bHQpID0+IHtcblx0XHRcdFx0XHRmb3IgKGNvbnN0IGluZGV4IGluIHRhc2tDb250YWluZXIudGFza3MpIHtcblx0XHRcdFx0XHRcdGNvbnN0IHRhc2sgPSB0YXNrQ29udGFpbmVyLnRhc2tzW2luZGV4XTtcblxuXHRcdFx0XHRcdFx0Y29uc3QgdHJhbnNsYXRlZFRleHQgPSByZXN1bHRbaW5kZXhdO1xuXHRcdFx0XHRcdFx0aWYgKHRyYW5zbGF0ZWRUZXh0ICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdHRhc2sucmVzb2x2ZSh0cmFuc2xhdGVkVGV4dCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnRhc2tFcnJvckhhbmRsZXIoXG5cdFx0XHRcdFx0XHRcdFx0dGFzayxcblx0XHRcdFx0XHRcdFx0XHRuZXcgRXJyb3IoXCJUcmFuc2xhdG9yIG1vZHVsZSBjYW4ndCB0cmFuc2xhdGUgdGhpc1wiKSxcblx0XHRcdFx0XHRcdFx0XHR0YXNrQ29udGFpbmVyLmNvbnRleHQsXG5cdFx0XHRcdFx0XHRcdFx0dGFza0NvbnRhaW5lci5wcmlvcml0eSxcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5jYXRjaCgocmVhc29uKSA9PiB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcihyZWFzb24pO1xuXG5cdFx0XHRcdFx0Zm9yIChjb25zdCB0YXNrIG9mIHRhc2tDb250YWluZXIudGFza3MpIHtcblx0XHRcdFx0XHRcdHRoaXMudGFza0Vycm9ySGFuZGxlcihcblx0XHRcdFx0XHRcdFx0dGFzayxcblx0XHRcdFx0XHRcdFx0cmVhc29uLFxuXHRcdFx0XHRcdFx0XHR0YXNrQ29udGFpbmVyLmNvbnRleHQsXG5cdFx0XHRcdFx0XHRcdHRhc2tDb250YWluZXIucHJpb3JpdHksXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSlcblx0XHRcdFx0LmZpbmFsbHkoZnJlZSk7XG5cdFx0fVxuXG5cdFx0dGhpcy53b3JrZXJTdGF0ZSA9IGZhbHNlO1xuXHR9XG5cblx0cHJpdmF0ZSB0YXNrRXJyb3JIYW5kbGVyKHRhc2s6IFRhc2ssIGVycm9yOiBhbnksIGNvbnRleHQ6IHN0cmluZywgcHJpb3JpdHk6IG51bWJlcikge1xuXHRcdGlmICh0YXNrLmF0dGVtcHQgPj0gdGhpcy5jb25maWcudHJhbnNsYXRlUmV0cnlBdHRlbXB0TGltaXQpIHtcblx0XHRcdGlmICh0aGlzLmNvbmZpZy5pc0FsbG93RGlyZWN0VHJhbnNsYXRlQmFkQ2h1bmtzKSB7XG5cdFx0XHRcdGNvbnN0IHsgdGV4dCwgZnJvbSwgdG8sIHJlc29sdmUsIHJlamVjdCB9ID0gdGFzaztcblx0XHRcdFx0dGhpcy5kaXJlY3RUcmFuc2xhdGUodGV4dCwgZnJvbSwgdG8pLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRhc2sucmVqZWN0KGVycm9yKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5hZGRUb1Rhc2tDb250YWluZXIoe1xuXHRcdFx0XHQuLi50YXNrLFxuXHRcdFx0XHRhdHRlbXB0OiB0YXNrLmF0dGVtcHQgKyAxLFxuXHRcdFx0XHRjb250ZXh0LFxuXHRcdFx0XHRwcmlvcml0eSxcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFNQSxJQUFBQSxVQUFBLEdBQUFDLE9BQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyR0E7Ozs7Ozs7QUFPQSxJQUFBQyxTQUFBO0VBWUMsU0FBQUEsVUFBWUMsVUFBcUMsRUFBRUMsTUFBd0I7SUFBM0UsSUFBQUMsS0FBQTtJQVRpQixLQUFBRCxNQUFNLEdBQThCO01BQ3BERSwwQkFBMEIsRUFBRSxDQUFDO01BQzdCQywrQkFBK0IsRUFBRSxJQUFJO01BQ3JDQyxxQkFBcUIsRUFBRSxJQUFJO01BQzNCQyxrQkFBa0IsRUFBRSxHQUFHO01BQ3ZCQyw0QkFBNEIsRUFBRSxJQUFJO01BQ2xDQyxvQkFBb0IsRUFBRTtLQUN0QjtJQWNPLEtBQUFDLGNBQWMsR0FBRyxDQUFDO0lBbUhULEtBQUFDLHFCQUFxQixHQUFHLElBQUlDLEdBQUcsRUFBaUI7SUF1RWhELEtBQUFDLFNBQVMsR0FBRyxJQUFJQyxHQUFHLEVBQTBDO0lBZ0I5RTs7OztJQUlRLEtBQUFDLGNBQWMsR0FBb0IsRUFBRTtJQXFCNUM7Ozs7SUFJUSxLQUFBQyx5QkFBeUIsR0FBRzs7TUFDbkMsT0FBTztRQUNOQyxJQUFJLEVBQUVkLEtBQUksQ0FBQ1ksY0FBYyxDQUFDRyxNQUFNLEtBQUssQ0FBQztRQUN0Q0MsS0FBSyxFQUFFLENBQUFDLEVBQUEsR0FBQWpCLEtBQUksQ0FBQ1ksY0FBYyxD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
