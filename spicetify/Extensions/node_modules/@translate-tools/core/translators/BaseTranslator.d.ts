import { TranslatorInstanceMembers, langCode, langCodeWithAuto } from './Translator';
export type CorsProxy = string | ((url: string) => string);
export type TranslatorOptions<O extends Record<any, any> = {}> = O & {
    /**
     * API endpoint URL
     */
    apiHost?: string;
    /**
     * Access key for requests to translator API
     */
    apiKey?: string;
    /**
     * Union text array to 1 request (or more, but less than usualy anyway).
     *
     * Option for reduce the number of requests, but it can make artefacts in translated text.
     *
     * Some modules may not support this feature.
     */
    useMultiplexing?: boolean;
    /**
     * Additional headers for requests
     */
    headers?: Record<string, string>;
    /**
     * Proxy prefix or transform function which return url with CORS proxy
     *
     * CORS proxy useful to avoid CORS error in browser or to mask server requests as browser requests.
     *
     * All requests will send through this proxy server and this server will modify headers
     */
    corsProxy?: CorsProxy;
};
/**
 * Basic abstract class for translator
 */
export declare abstract class BaseTranslator<C extends Record<any, any> = {}> implements TranslatorInstanceMembers {
    static readonly translatorName: string;
    static isRequiredKey: () => boolean;
    static isSupportedAutoFrom: () => boolean;
    static getSupportedLanguages: () => langCode[];
    abstract getLengthLimit(): number;
    abstract getRequestsTimeout(): number;
    protected readonly options: TranslatorOptions<C>;
    constructor(options?: TranslatorOptions<C>);
    abstract translate(text: string, langFrom: langCodeWithAuto, langTo: langCode): Promise<string>;
    abstract translateBatch(text: string[], langFrom: langCodeWithAuto, langTo: langCode): Promise<Array<string | null>>;
    checkLimitExceeding(text: string | string[]): number;
    /**
     * Util to wrap url to CORS proxy
     */
    protected wrapUrlToCorsProxy: (url: string) => string;
}
